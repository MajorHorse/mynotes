### 引言

互联网时代，信息传输的基础媒介是比特流，即承载着各种有效信息的01串。换句话说，我们在手机上或者电脑上看到的各类媒体信息，例如文字信息、图片信息亦或是视频信息，其根源上都是一些由二进制的0和1组成的比特流。只要信息存在着流动，那么在传输过程中必然有可能出现差错。以二进制下传输数字3为例，3表示为八位二进制为0000 0011，传输过程中，可能会出现某种不可预测的原因，使得序列某一位或者某几位产生错误。那么，我们应该采取何种的方法来检测出错误的信息呢？

### 一、奇偶校验

奇偶校验是一种较为简单的校验方法，其检测的是被传输的一组二进制代码数位中的“1”的个数，根据1的个数是奇数或是偶数，又可以分为奇校验和偶校验。我们以奇校验为例，说一下其校验的详细过程。

奇校验即**确保传输的每一组二进制代码数位中1的个数为奇数**。以一个字节为例，一个字节包含八个无符号比特位。我们仍以数字3为例，看一下其引入奇校验的过程。

十进制的3在二进制下存储在一个字节内，表示为 0000 0011 ，当引入奇校验时，我们需要把最高位的0设置为校验位，即第一个0不存储数据信息，仅作为校验位存在。此时，表示数据信息的比特位数变成了7位，即 000 0011。可以看到，此时整个数据中位数值为1的数据位的个数是2，即偶数，所以我们需要在最高位补1，确保整组二进制代码中数位值为1的个数为奇数，即1000 0011。

同理，当传输2时，2的二进制表示为000 0010，此时1的个数已经为奇数，则需要在最高位补0，即0000 0010。

假设传输3时某一位出现了问题，1000 0011变成了1100 0011，接收方收到数据1100 0011后，首先会校验整组数据中1的个数，发现其中1的个数为偶数，所以立刻便知道了这组数据是不对的。

奇校验的做法很简单也很高效，但是却存在着两个不可调和的弊端：

1.只能校验奇数个位数错误，不能发现偶数个位数错误

假设传输3是有两位数都发生了错误，即1000 0011变为了 1110 0011，当接收方接收到这组数据后，首先校验整组数据中1的个数，发现1的个数为奇数，便会认为这组数据并没有问题。所以，当有偶数个错误时，奇校验并不能发现其中的问题。

2.只能发现问题，却不能解决问题

很显然，通过奇校验的方式虽然能发现数据是否在传输过程中发生了错误，但是却并不能定位到究竟是哪一位出了错误。

偶校验的原理和奇校验相同，只是偶校验是**确保传输的每一组二进制代码数位中1的个数为偶数**。所以，奇校验存在的问题偶校验也依然存在。

那么，是否存在着一种校验方法，可以准确的定位到究竟是哪一位出现了错误呢？答案当然是肯定的：汉明码。

### 二、汉明码

在说汉明码之前，我想简要的讲一下汉明码的由来-----因为当昨天整明白整个汉明码的逻辑推导过程后，我是真的被汉明的智慧给折服了。此刻的汉明在我心中，真他娘的是个天才！此刻还是得小声bb两句：人与人的差距是真的大，大佬们的智慧着实让我无法企及。

事情还要从上个世纪四十年代开始讲起，那时候的汉明老爷子还在大名鼎鼎的贝尔实验室上班（此刻又想小声bb两句：贝尔实验室真是个神一样的地方，可以说是直接推动了人类科技的发展）。那个时候世界上第一台真正意义上的电脑“埃尼阿克”还没有被发明，汉明操作着一台用于计算的类似电脑的机器，这台机器的输入端是依靠打孔纸带。靠纯物理的方法来录入数据，可想而知必然会发生错误。平时在工作日里还好，因为有专门的操作员值守，机器发现错了会立刻报警，所以操作者可以记录并解决卡带纸上出现的错误。但是，到了休息日或者节假日就彻底完犊子了：由于没人值守，机器发现错误报警后没人处理，所以仍然会进行下一个工作。汉明同志在周末工作时，由于机器的操作员都放假了，所以不断地会遇到发生错误而导致从头开始执行程序，这使得他非常烦。于是，他便开始思考这样一个问题：既然机器可以发现问题，那么为什么不能想办法让机器变得更加智能，即不仅能准确定位到错误发生的位置，还能自动纠正错误呢？基于以上的猜想，汉明在一次次的改善后，终于探究出了如今具有准确定位错误和自动纠错的汉明码校验法。

在介绍汉明码之前，我们不妨看一下如下的一个有趣案例：把1-7七个数字通过某种方式传输（传输的过程中有可能会出现错误），为了及时发现并准确定位至出错的数字（**此处假设只会发生一位数字的错误**），我们可以按照如下图所示把这七个数字分为P1、P2、P3三组：

![image-20201011225505030](../img/汉明码/数字分组.png)

P1组：1	2	3	4

P2组：2	3	5	6

P3组：3	4	6	7

分组完毕后，我们给每一组都加一个校验位（接收方可以通过校验位得知本组数据在传输过程中是否出错，但是无法准确定位至错误位置），然后把这三组作为一个整体发送出去。

接收方收到数据后，经过查看各小组的校验位，发现第P1错了，P2和P2都没错。根据分组情况，我们可以轻易地判断出一定是数字1出错了：因为属于P1但又不属于P2和P3的数字只有1。

同理，若是接收方发现P1和P2都错了，但是P3没问题，我们也可以根据分组轻易的定位到是数字2出现了问题；若是接收方发现P1、P2和P3都错了，显然一定是数字3出现了问题。

可以发现，经过特定的分组后，1-7这七个数字在传输过程中任意一个数字发生了错误，就都能被我们给检测到。而汉明码的内核，其实跟这个例子是一样的。

思维延伸开来，我们把上述例子中用来检测数字错误的方法发散至计算机领域，即只有0和1存在的世界。

进入计算机的世界后，我们发现事情似乎变得更容易处理了：在刚才的例子中我们虽然能定位至出错的数字所在的位置，但是却并不能将出错的数字恢复至正确的状态。换句话说就是，数字3在传输过程中可能变成了8，我们只能知道传过来的这个8是错误的，但是并不能知道正确的是3，即不能纠错。然而，计算机的世界只有二进制的0 1字符，接收方发现传过来的0出错了，则正确的必然是1，反之亦然。

接下来，我们还需要引入一个叫做校验码的东西。我们只需要记住，在传输一串数据时，校验码位于这串数据2的i位置上。也就是说，传输一串8bit的数据，校验码要占据其中四个比特位，即1,2,4,8；传输一串10bit的数据，校验码也是占据其中四个比特位，如下图所示：

![image-20201011232357264](../img/汉明码/校验码的位置.png)

上图中橙色填充的比特位存储校验码，而白色的格子则用来存储数据。

好，假设现在我们需要传输一串12位的数据，根据以上可以得出，这串数据需要4个校验位，即能存储有效数据的只有8个比特位。

![image-20201013195658859](../img/关于数据校验--奇偶校验与汉明码/12位分组.png)

现在，你可能大概已经明白了为什么校验码的位置要设置在2的i次方位置上了：这样可以使得每组分好的数据都能拥有一个校验码。

当然，这种神奇的分组方式可并不是凭空产生的，而是汉明老爷子经过一次次的演算而得来的。在这里不得不再次想向智慧的汉明老爷子致敬......

下面，构造一组带汉明码校验的数据

![image-20201013200804040](../img/关于数据校验--奇偶校验与汉明码/构造数据.png)

假设传输过程中发生了错误，第九位的1变成了0

![image-20201013200949720](../img/关于数据校验--奇偶校验与汉明码/出错数据.png)

接下来，看一下汉明码究竟是如何纠错的

P1组 1,3,5,7,9,11  发现本组内1的个数为偶数，出错了，我们需要补1才能构成奇数   1

P2组 2,3,6,7,10,11 本组内1的个数已经为奇数了，补0即可										    0

P3组 4,5,6,7,12     本组内1的个数已经是奇数了，补0即可											 0

P4组 8,9,10,11,12 本组内1的个数为偶数，需要补1                                                         1

我们把补的数倒着写，即1001，转换为二进制是9，说明第9个位置错了，0应该是1，纠错完毕。

是不是贼鸡儿神奇？

### 猪喝毒药问题

搞明白汉明码后，我们不妨来看一下它的扩展应用（此题出自LeetCode第458题：可怜的小猪）

题目描述：

有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。

问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？

思路：我们不妨沿用汉明码纠错设计的思路，即分组。假设第496桶水有毒，因为要求的是最小的小猪数，我们不妨把这1000桶水按五进制分组，496的五进制分组为03441

Step1  将1000桶水按五进制编码，然后分成五组，分别为XXXX0,XXX0X,XX0XX,X0XXX,0XXXX。

Step2 捉来五头猪，喂第一头猪五进制下最后一位编号是0的水，即XXXX0；第二头猪五进制下倒数第二位为0的水，即XXX0X；以此类推

Step3 十五分钟后，发现第五头猪死亡，说明有毒的哪桶水编号为0XXXX形式，接下来，把剩下的四头小猪编号，喂一号猪五进制下最后一位编号为1的水，即0XXX1；喂第二头猪五进制下倒数第二位编号为1的水，即0XX1X，依次类推

Step3 十五分钟后，发现一号猪死亡，说明有毒的水的编号为0XXX1。接下来，剩下的三头小猪在此编号，喂一号猪喝五进制下倒数第二位为2的水，喂二号猪喝五进制下倒数第三位为2的水，喂三号猪喝五进制下倒数第四位为2的水

Step4 十五分钟后，所有猪都活着；接下来，喂一号猪喝五进制下倒数第二位为3的水，喂二号猪喝五进制下倒数第三位为3的水，喂三号猪喝五进制下倒数第四位为3的水

Step5 十五分钟后，发现三号猪死了，说明有毒水的编号为03XX1。前几轮的实验已经排除了其他数子，故桶的编号为03441，即496。