### 前言

最近一周被一道解数独问题求解给折磨的死去活来，其问题描述如下：

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则：

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

空白格用 '.' 表示。

刚看到这个问题时，脑子里确实没有一丝头绪：现实生活中的数独问题我也没怎么做过，更别说用代码实现了。没办法，只能看题解。尴尬的是，看了半天题解的我脑子里依然是一团乱麻，都不知道这写的到底是啥。题解里面说这道题的解法核心是回溯法，关于回溯法，我学习的也不够充分，于是只好把回溯法的经典问题给了解学习了一下。

### 全排列问题

看了下回溯法的定义后，我大概了解了它的思想其实是把问题求解的过程化解为一颗树或者图，然后以深度优先搜索的方式遍历每一条路径，穷举所有可能的结果。以数字的全排列为例

```java
/**
 * 全排列问题：给出一串不重复的数字，求出此串数字的所有全排列组合
 * @param nums 给定的数字
 * @return 所有可能的全排列组合
 *          假设数字为[1,2,3]，我们相求出它的全排列，求解过程大致可以用下图来表述
 *                   1              2               3
 *              2         3    1          3     1       2
 *          3               2 3              1 2          1
 *
 *          以上求解过程本质上就是构造了一棵求解树，然后通过BST算法遍历树的每一条路径
 *
 */
/**存放最终求解的结果*/
List<List<Integer>> res=new LinkedList<>();
/**每次遍历出的树的路径*/
LinkedList<Integer> track=new LinkedList<>();
public List<List<Integer>> permute(int[] nums){
    backTrack(nums);
    return res;
}

/**
 * 求解的核心算法：回溯法
 * @param nums
 */
public void backTrack(int[] nums) {
    //跳出条件
    if(track.size()== nums.length){
        res.add(new LinkedList<>(track));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if(track.contains(nums[i])){
            continue;
        }
        track.add(nums[i]);
        backTrack(nums);
        System.out.println(track.toString());
        //这是回溯的关键步骤：状态恢复,即恢复到上一步的状态  
        track.removeLast();
        System.out.println(track.toString());
    }
}
```

### 八皇后问题

提到回溯法，不得不说的另一个问题就是经典的八皇后问题，题目描述如下：

在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问一共有多少种摆法。

```java
/**
 * @author Major Tom
 * @date 2020/9/20 14:18
 * @description 八皇后问题
 */
public class EightQueens {
    public static void main(String[] args) {
        EightQueens eq=new EightQueens();
        eq.eightQueens();
    }
/**
     * 结果:o o o o o o o * 
     *     o o o o o * o o 
     *     o o o * o o o o 
     *     o o o o o o * o 
     *     o o * o o o o o 
     *     * o o o o o o o 
     *     o o o o * o o o 
     *     o * o o o o o o 
     */
    public void eightQueens() {
        //记录是否已被放置皇后
        boolean[][] flag=new boolean[10][10];
        //记录某一行是否已经放置了一个皇后
        boolean[] row=new boolean[10];
        //记录某一列是否已经放置了一个皇后
        boolean[] col=new boolean[10];
        //存储最后皇后放置的位置
        char[][] result=new char[10][10];
        backTrack(flag,1,row,col,result);
        for (int i = 1; i < result.length-1; i++) {
            for (int j = 1; j < result[0].length-1; j++) {
                System.out.print(result[i][j]+" ");
            }
            System.out.println();
        }
    }

    private void backTrack(boolean[][] flag, int index,boolean[] row,boolean[] col,char[][] result) {
        //单次搜寻终止条件，即已经扫描了八行
        if(index>=flag.length-1){
            for (int i = 1; i < result.length; i++) {
                for (int j = 1; j < result[0].length; j++) {
                    if(flag[i][j]){
                        result[i][j]='*';
                    }else{
                        result[i][j]='o';
                    }
                }
            }
            return;
        }
        //本质上是按行扫描，逐个填充。即一行为单位，每次从左往右逐格填充皇后，同时判断皇后的放置是否与之前冲突。若冲突，则回溯，反之继续
        for (int i = 1; i < flag[0].length-1; i++) {
            if(flag[index-1][i-1]||flag[index+1][index+1]||flag[index-1][i+1]||flag[index+1][i-1]||row[index]||col[i]){
                continue;
            }
            //标记已经放置皇后
            flag[index][i]=true;
            row[index]=true;
            col[i]=true;
            //递归，找下一层
            backTrack(flag,index+1,row,col,result);
            //状态恢复
            flag[index][i]=false;
            row[index]=false;
            col[i]=false;
        }
    }
}
```

以上是我针对八皇后问题肝了半天做出的初始解法，简称笨B解法。

为何称之为笨B解法呢？原因在于这种解法虽然破解了八皇后问题，可是做法却很糙：求解过程粗暴，硬循环；结果不能直接用，还需要找个数组来存；最最重要的是，他并没有给出所有解法的数量。所以，我有花了点时间把它给优化了下



优化完毕，问题又来了：要是皇后的个数不确定呢？即N皇后问题，那通俗的解法应该怎么写呢