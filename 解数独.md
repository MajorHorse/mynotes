### 前言

最近一周被一道解数独问题求解给折磨的死去活来，其问题描述如下：

编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则：

    数字 1-9 在每一行只能出现一次。
    数字 1-9 在每一列只能出现一次。
    数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

空白格用 '.' 表示。

刚看到这个问题时，脑子里确实没有一丝头绪：现实生活中的数独问题我也没怎么做过，更别说用代码实现了。没办法，只能看题解。尴尬的是，看了半天题解的我脑子里依然是一团乱麻，都不知道这写的到底是啥。题解里面说这道题的解法核心是回溯法，关于回溯法，我学习的也不够充分，于是只好把回溯法的经典问题给了解学习了一下。

### 全排列问题

看了下回溯法的定义后，我大概了解了它的思想其实是把问题求解的过程化解为一颗树或者图，然后以深度优先搜索的方式遍历每一条路径，穷举所有可能的结果。以数字的全排列为例

```java
/**
 * 全排列问题：给出一串不重复的数字，求出此串数字的所有全排列组合
 * @param nums 给定的数字
 * @return 所有可能的全排列组合
 *          假设数字为[1,2,3]，我们相求出它的全排列，求解过程大致可以用下图来表述
 *                   1              2               3
 *              2         3    1          3     1       2
 *          3               2 3              1 2          1
 *
 *          以上求解过程本质上就是构造了一棵求解树，然后通过BST算法遍历树的每一条路径
 *
 */
/**存放最终求解的结果*/
List<List<Integer>> res=new LinkedList<>();
/**每次遍历出的树的路径*/
LinkedList<Integer> track=new LinkedList<>();
public List<List<Integer>> permute(int[] nums){
    backTrack(nums);
    return res;
}

/**
 * 求解的核心算法：回溯法
 * @param nums
 */
public void backTrack(int[] nums) {
    //跳出条件
    if(track.size()== nums.length){
        res.add(new LinkedList<>(track));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if(track.contains(nums[i])){
            continue;
        }
        track.add(nums[i]);
        backTrack(nums);
        System.out.println(track.toString());
        //这是回溯的关键步骤：状态恢复,即恢复到上一步的状态  
        track.removeLast();
        System.out.println(track.toString());
    }
}
```

### 八皇后问题

提到回溯法，不得不说的另一个问题就是经典的八皇后问题，题目描述如下：

在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问一共有多少种摆法。

 