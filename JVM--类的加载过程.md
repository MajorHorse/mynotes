## 前言

​		我们都知道，Java程序写的初始.java文件是不能直接运行的，而是需要被编译后生成后缀名为.class的字节码文件后，再由JVM读取并执行。如下图所示

![image-20200618113424016](C:\Users\mylov\Desktop\笔记相关\编译与读取.png)

​		在语言层面上来讲，创建对象通常仅仅是一个new关键字而已，但在JVM内部，对象的加载与读取却是一个复杂无比的流程。

## 类的加载

​		在JVM中，一个类的生命周期大致包括以下七个阶段：加载、验证、准备、解析、初始化、使用和卸载。

![image-20200618123401179](C:\Users\mylov\Desktop\笔记相关\类的生命周期.png)

​		加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析阶段则不一定。解析在某种情况下可以在初始化之后再发生，这是为了支持Java语言的运行时绑定（即动态绑定）。这些阶段通常是相互交叉地混合式进行的，经常会在一个阶段执行的过程中调用、激活另一个阶段。

### 加载

​		在加载阶段，虚拟机需要完成以下三件事情：

​		1.通过一个类的全限定名来获取定义此类的二进制字节流；

​		2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

​		3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

​		对于数组类而言，由于数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建。一个数组类创建的过程要遵循以下准则：

​		1.如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识；

​		2.如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组标记为与引导类加载器关联；

​		3.数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。

​		加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 验证

​		目的：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

​		验证阶段大致分为以下四个检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

​		文件格式验证：检验字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。

​		元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。

​		字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

​		符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候。这个转化动作将在连接的第三阶段----解析阶段中发生。

### 准备

​		正式为类型变量分配内存并设置类变量初始值。注意，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。而且，这里分配的初始值通常情况下是数据类型的零值。

### 解析

​		JVM将常量池中的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

​		符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）

​		直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。

### 初始化

​		到了此阶段，才开始真正执行Java类中定义的代码（或者说是字节码）。

​		在准备阶段，变量已经赋过一次系统要求的初始值。而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。一句话描述这个阶段就是执行类构造器< clinit >()方法的过程。

​		在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

​		1.声明类变量是指定初始值

​		2.使用静态代码块为类变量指定初始值

​		JVM初始化步骤

​		1.假如这个类还没有被加载和连接，则程序先加载并连接该类

​		2.假如该类的直接父类还没有被初始化，则先初始化其直接父类

​		3.假如类中有初始化语句，则系统依次执行这些初始化语句

​		类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

​		1.创建类的实例，也就是new的方式

​		2.访问某个类或接口的静态变量，或者对该静态变量赋值

​		3.调用类的静态方法反射（如 Class.forName(“com.shengsiyuan.Test”)）

​		4.初始化某个类的子类，则其父类也会被初始化

​		5.Java虚拟机启动时被标明为启动类的类（ JavaTest）

​		6.直接使用 java.exe命令来运行某个主类

## 类加载器

​		Java语言系统自带有三个类加载器：

​		Bootstrap  ClassLoader  ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。

​		Extention ClassLoader  ：扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载被java.ext.dirs系统变量所指定的路径中的所有类库。

​		Appclass Loader：默认类加载器，也称为SystemAppClass。 加载当前应用的classpath的所有类。默认类加载器。

​		其加载顺序为Bootstrap ClassLoader  -->  Extention ClassLoader  -->  Appclass Loader。

### 加载方式

​		类主要有以下3中加载方式：

​		1.通过命令行启动应用时由JVM初始化加载含有main()方法的主类。

​		2.通过Class.forName()方法动态加载，会默认执行初始化块（static{}）。Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。

​		3.通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。

### 双亲委派原则

​		下图所示的这种类加载器的层级关系，被称之为类加载器的双亲委派模型

![image-20200618135034244](C:\Users\mylov\Desktop\笔记相关\双亲委派模型.png)

​		它的工作流程是： 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。它的主要优点是可以避免重复加载。父类已经加载了，子类就不需要再次加载，这样更加安全，很好的解决了各个类加载器的基础类的统一问题。如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。

## 实例

​		以以下代码为例，详细撸一遍对象从创建到方法调用的整个流程

```Java
public class Person {
    private String name;
    private int age;
    public static String hobby="恶心心";

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public static void main(String[] args) {
        System.out.println(Person.hobby);
        Person person=new Person("方大醒",24);
        System.out.println(Person.hobby);
        Person.hobby="吃饭饭，恶心心";
        System.out.println(Person.hobby);
    }
     /*
        运行结果:恶心心
                恶心心
                吃饭饭，恶心心
     */
}
```

​		首先，我们要把Person.java文件经过编译器编译成Perso.class文件，然后装载入JVM，进过加载、验证，在准备阶段时，静态变量hobby会在方法区被分配内存，然后被赋值为null；代表Person的Class对象会在方法区中被分配内存。

​		此时，方法区内存储着class文件和赋值为null的hobby字段

​		初始化时，会首先对静态字段hobby赋值“恶心心”。然后，开始执行类中的方法。

​		1.首先读取到程序入口，即main方法，在虚拟机栈中为main()创建栈帧，此时，方法区中的hobby值为“恶心心”。

![image-20200618145559357](C:\Users\mylov\Desktop\笔记相关\step1.png)

​		2.执行new Person("方大醒"，24)，运行构造函数，实例化一个对象，并把该对象在堆内存中的地址赋值给栈中的person变量

![image-20200618161051649](C:\Users\mylov\Desktop\笔记相关\step2.png)

​		3.为方法区中的hobby赋值“吃饭饭，恶心心”

![image-20200618161318552](C:\Users\mylov\Desktop\笔记相关\step3.png)

## 总结

​		类的加载过程感觉每一一步单独拿出来说都能研究好久，里面牵扯到的东西实在是太多了。毕竟也不能一口气吃个胖子，更何况这部分东西值得注意的点又那么多，慢慢来吧，以后在开发中继续领悟。

